\chapter{Teoretické porovnanie API tokenov}

\label{kap:teoreticke} % id kapitoly pre prikaz ref

V tejto kapitole porovnáme rôzne parametre konkrétnych tokenov podľa informácií získaných z ich dokumentácií a iným zdrojov. Tieto informácie sme zhrnuli v kapitole \ref{kap:typy}. Pri jednotlivých parametroch vysvetlíme ich význam a teda aj dôležitosť pri porovnávaní tokenov. Porovnávať budeme všetky tokeny popísané v kapitole \ref{kap:typy} a nepriehľadný token popísaný v podkapitole \ref{sec:opaque}. Nepriehľadný token je formát tokenu, nie konkrétny token. Pre jednoduchosť budeme v tejto kapitole pod pojmom nepriehľadný token myslieť náhodný reťazec s podpisom, ktorý vznikol pomocou asymetrického širovania. 

Kapitola je štruktúrovaná podľa porovnávaných vlastností a jej výsledkom je tabuľka \ref{tab:porovnanie} zhrňujúca závery porovnania.

\section{Bezpečnosť}

V rámci porovnávania bezpečnosti tokenov nebudeme detailne rozoberať bezpečnosť jednotlivých kryptografických funkcií. Detaily ohľadom týchto funkcií je možné nájsť v ich citovaných dokumentáciach. Všetky tokeny ponúkajú možnosť použiť kryptografické funkcie, ktoré sú všeobecne považované za bezpečné.

Zameriame sa na porovnanie kryptografických primitív a z nich vyplývajúcich bezpečnostných kvalít a na náchylnosti na zraniteľnosti vyplývajúce zo špecifikácie tokenu. Konkrétne rozoberieme tri bezpečnostné problémy:

\begin{itemize}
    \item Útok pomýlením algoritmu (angl. algorithm confusion attack) -- útočník donúti overovaciu službu použiť nesprávny algoritmus na overenie podpisu tokenu. 
    \item Útok opakovaním (angl. replay attack) -- útočník odchytí token a následne ho opakovane používa na autorizáciu vlastných požiadaviek. Tento útok je priamo spojený s hlavnou nevýhodou používania tokenov v autentifikačnej a autorizačnej schéme a to problémom odvolania (angl. revocation).
    \item Problém odvolania -- problém odvolania je spočíva v schopnosti služby zneplatniť vydané tokeny. Napríklad po odhlásení používateľa alebo po zitení, že token bol zneužitý.
\end{itemize}

\subsection{Kryptografické primitíva}

Pri tokenoch rozoznávame tri kryptografické primitíva a to asymetrické šifrovanie vo forme elektronického podpisu, symetrické šifrovanie a hešovanie s kľúčom. Výstupom hešovania s kľúčom je hešovaný autentifikačný kód. 

Symetrické šiforvanie sa vrámci nami porovnávaných tokenov využíva na šifrovanie obsahu tokenu a teda na ochranu dôvernosti informácií uložených v tokene. Elektronický podpis a hešovanie zaručujú ochranu autenticity a integrity tokenu. Rozdiel v použití elektronického podpisu a hešovania je v tom, že v prípade elektronického podpisu ide o asymetrické šifrovanie, teda  podpis vie overiť ľubovoľná entita, ktorá pozná verejný kľúč tvoriaci dvojicu so súkromných kľúčom, ktorým bol token podpísaný. Takýto verejný kľúč je zväčša verejne dostupný a vie ho získať ľubovoľná entita. V prípade hešovania ide o symetrickú kryptografiu, pravosť hešovaného autentifikačného tokenu vie overiť len entita, ktorá pozná tajný kľúč, ktorým bol token zahešovaný, čo je často len entita, ktorá token vytvorila.

Výhodou elektronického podpisu teda je, že autenticitu a integritu tokenu môže overiť ľubovoľná entita. Výhodou hešovania je, že je rýchlejšie pri generovní kľúča a generovaní aj overovaní podpisu ako algoritmy pre digitálne podpisy, aj keď v prípade niektorých algoritmov nad eliptickými krivkami je rýchlosť porovnateľná \cite{hmac_perf}. Pri porovnaní iba algoritmov definovaných v JWA \cite{hmac_jwt_perf} vystupuje hešovanie s kľúčom vždy rýchlejšie.

V prípade JWT si môžeme vybrať, či budeme používať elektronický podpis alebo hešovanie s kľúčom a pomocou nastavenia oprávnenia \textit{alg} v hlavičke na požadovanú hodnotu. Všetky možnosti hodnôt oprávanenia \textit{alg} definuje  JWA \cite{jwa_rfc}. Štandard ponúka aj možnosť \textit{alg=none}, v tomto prípade nezaručuje JWT žiadne bezpečnostné kvality a je to jedna zo známych zraniteľností \cite{jwt_vul} JWT. Ak služba akceptuje aj JWT s \textit{alg=none} ako platné tokeny, útočník jednoducho zamení hodnotu \textit{alg='čokoľvek'} na \textit{alg=none}, odstráni podpis z tokenu a môže ľubovoľne zmeniť token, napríklad si zvýši autorizačné práva. Bezpečné implementácie JWT, by nikdy nemali tokeny s \textit{alg=none} považovať za platné.

PASETO využíva v prípade lokálneho využitia hešovanie a v prípade verejného využitia elektronický podpis. Fernet, Branca a Macaroon využívajú hešovanie s kľúčom a Biscuits využíva elektronický podpis. Nepriehľadný token sme pre potreby tejto kapitoly definovali s použitím elektronického podpisu.

Symetrické šifrovanie a z neho vyplývajúcu ochranu dôvernosti umožňujú tokeny JWT, konkrétne vo forme JWE, PASETO s lokálnym využitím, Fernet a Branca. Biscuits a Macaroons neposkytujú žiadnu ochranu dôvernosti. Nepriehľadný token tiež neposkytuje ochranu dôvernosti, no z definície nenesie žiadnu informáciu, teda v jeho prípade nie je dôvernosť čoho chrániť.

\subsection{Útok pomýlením algoritmu}

V prípade podpisov tokeny používajú asymetrické šifrovanie a teda dvojicu súkromného a verejného kľúča alebo hešovanie s kľúčom, ktorý je súkromný. Jediný kľúč, ku ktorému má útočník ľahký prístup je verejný kľúč z dvojice kľúčov použitých pri asymetrickom šifrovaní. Útok pomýlením algoritmu potom prebehne tak, že útočník podpíše token funkciou hešovania s kľučom, kde ako kľúč použije získaný verejný kľúč. Následne oklame overovaciu službu, aby token overila pomocou funkcie hešovania s kľúčom, kde ako kľúč použije tento verejný kľúč. Takýmto spôsobom overovacia služba potrvdí platnosť ľubovoľného tokenu, ktorý jej útočník podvrhne. Aby bol tento útok úspešný, musí overovacia služba používať asymetrické šifrovanie na podpis tokenu a zároveň podporovať aj vyvtváranie podpisu tokenu pomocou hešovania s kľúčom.

Existuje viacero spôsobov ako predchádzať útokom pomýlením algoritmu. Najspoľahlivejším spôsobom je podpora jediného kryptografického primitíva na podpis tokenu, napríklad jedine elektronický podpis alebo jedine hešovanie s kľúčom. Takto útočník jednoducho nemá ako oklamať overovaciu službu, ktorý algorimus má použiť pri overovaní, lebo pozná len jeden a ten má implicitne daný. 

V prípade použitia viacerých kryptografických primitív sa dá predchádzať týmto útokom pomocou vloženia identifikátora kľúča, ktorým sa overí podpis do tokenu. Následne pri overovaní služba zistí, ktorým algoritmom bol token podpísaný. Taktiež z pridaného identifikátora odvodí, ktorý kľúč má použiť na overenie, ak je to verejný kľúč z dvojice kľúčov pre asymetrické šifrovanie, ale zistený podpisový algoritmus z tokenu je hešovanie s kľúčom, vyhodnotí token za neplatný. Útočník už nedokáže oklamať službu aby použila zlý algoritmus na overienie pospisu, lebo ak by sa o to pokúsil nebude sedieť identifikátor kľúča s podpisovým algoritmom. Úspešnosť tejto métody ochrany nezávisí len od špecifikácie tokenu, ale najmä od jeho konkrétnej implementácie, pretože záleží na implementácií ako bude pracovať s identifikátorom kľúča a či vôbec vyžaduje jeho použitie.

Tokeny využívajúce jediné ktyptografické primitívum sú Fernet, Branca, Biscuits a Macaroons. Sú teda bezpečné proti útokom pomýlením algoritmu, no všetky nejakým spôsobom podporujú budúce verzionovanie tokenu, ktoré môže teoreticky priniesť aj nové kryptografické primitíva. Preto do budúcnosti môžu byť zraniteľné útokom pomýlením algoritmu ak nebudú implementovať inú ochranu voči tomuto útoku. V súčasnosti už Macaroons aj Biscuits vyžadujú vloženie identifikátora kľúča do tokenu v rámci ich formátov, teda aj v prípade podpory ďalších kryptografických primitív budú bezpečné proti útokom pomýlením algoritmu.

Jediné kryptografické primitívum využíva aj nepriehľadný token, ale v tomto prípade to nie je veľmi dôležité, lebo nenesie žiadnu informáciu a všetky autorizačné údaje sú uložené v stave overovacej služby. Teda aj v prípade úspešného útoku pomýlením algoritmu, služba síce vyhodnotí podpis tokenu za platný, no ak nezodpovedá žiadnym dátam uloženým v stave služby, tak neprinesie útočníkovi žiadne autorizačné práva.

Viac kryptografických primitív a využívú JWT a PASETO. Obe podporujú asymetrické šifrovanie aj hešovanie s kľúčom na podpisovanie tokenu. V prípade JWT bol útok pomýlením algoritmu jednou zo známych zraniteľností v niektorých implementáciach \cite{jwt_vul}. Konkrétne útok prebiehal tak, že útočník si vybral službu používajúcu elektronický podpis. Získal jej verejný kľúč \textit{pub\_key}, vytvoril podvodný token \textit{mal\_token} a do jeho hlavičky zapísal \textit{alg=HS256} (HS256 označuje funkciu HMAC-SHA256), následne funkciou HMAC-SHA256 podpísal token s využítím verejného kľúča služby ako tajného kľúča pre funkciu. Služba, ktorá využívala zraniteľnú knižnicu a na podpisovanie iba elektronický podpis overila token zavolaním funkcie knižnice, napríklad \textit{verify(mal\_token, pub\_key)}, lebo si myslela, že overuje token podpíaný elektronickým podpis a jeho overenie teda treba verejný kľúč \textit{pub\_key}. Knižnica následne prečítala z tokenu, že má overiť podpis pomocou HMAC-SHA256 a využiť pri tom \textit{pub\_key} ako kľúč. Toto overenie bolo samozrejme úspešné, lebo token bol naozaj podpísaný funkciou HMAC-SHA256 s kľúčom \textit{pub\_key}. V súčastnosti už tieto konkrétne implementácie zaviedli ochranu voči útoku pomýlením algoritmu (pomocou identifikátora kľúča), no nič nezaručuje, že neexistujú iné implementácie s touto zraniteľnosťou. Popísaný útok dáva útočníkovi možnosť získať ľubovoľné práva, lebo celý \textit{mal\_token} môže vytvoriť presne tak ako potrebuje. Išlo teda o veľmi nebezpečný útok.

PASETO využíva verzionovanie tokenu ako prevenciu voči útoku pomýlením algortimu. Ide o podobnú techniku ako pri vložení identifikátora kľúča do tokenu, no navyše vyžaduje kontrolu formátu kľúča. Špecifikácia PASETO \cite{paseto_git} prikazuje každej knižnici, ktorá chce implementovať PASETO, logicky rozlišovať medzi kľúčami určenými pre rôzne podpisové funkcie. V rámci špecifikácie sa ochrane voči útoku pomýlením algoritmu venuje dedikovaný dokument \cite{alg_lucidity}. Kľúč k ľubovoľnému algortimu musí byť vždy uložený tak, aby sa dalo jasne určiť, pre ktorý algoritmus sa má použiť. Tento cieľ sa dá dosiahnuť napríklad tak, že sa kľúč uloží v nejakej štruktúre spolu s verziou a využitím tokenu. Následne pri validácií podpisu tokenu musí prebehnúť kontrola rovnosti verzie a využitia v kľuči s verziou a využitím v tokene. Podobne ako pri JWT popísaná ochrana bude úspešná len v prípade, že ju knižnice implementujúce PASETO budú využívať. Výhodou PASETO je, že sa ochrana vyžaduje v špecifikácii, teda každá knižnica, ktorá chce úspešne implementovať špecifikáciu PASETO ju musí implementovať. V prípade JWT štandard \cite{jwt_rfc} nevyžaduje využitie identifikátora kľúča.

\subsection{Útok opakovaním a problém odvolania}

Útok opakovaním a problém odvodenia sú úzko späté pojmy. Konkrétne riešenie problému odvolania je ochranou voči útoku opakovaním. Ak by služba vedela okamžite zneplatniť ľubovoľný ňou vydaný token, k útoku opakovaním by nemohlo dôjsť, prípadne by bol ihneď zastavený po odhalení. Úplne predísť útoku opakovaním sa pri využívaní nositeľským tokenov na autorizáciu nedá. Z definície autorizuje nositeľský token požiadavku, ktorú sprevádza ak je sám platný. Teda ak ho dokáže útočník získať a použiť v správnom kontexte, bude úspešný.

Hlavnou príčinou problému odvolania je udržiavanie stavu v tokene a nie v databáze autorizačnej služby. Ak by si služba udžiavala stav o vydaných tokenoch, jednoducho by token, ktorý chce odvolať označila za neplatný. Tento prístup sa dá využiť s nepriehľadným token, lebo v jeho prípade si už aj tak musí autorizačná služba udržiavať stav o vydaných tokenoch.

Pri validáciá ostatných tokenov sa autorizačná služba spolieha len na informácie v tokene a uložené kľúče na overovanie podpisov. Samozrejme môže štruktúrovaný token obsahovať identifikátor a podľa tohto identifikátora si o ňom môže autorizačná služba udržiavať stav, či je token platný, v databáze. JWT má pre tento účel štandardom dané oprávnenie \textit{jti} (JWT ID). Takto by však použitie tokenov na autorizáciu stratilo signifikantnú výhodu oproti iným schémam zabezpečenia.

Autorizačná služba by si nemusela o každom tokene pamätať, či je platný alebo nie, stačí si jej pamätať množinu platných (whitelist) alebo množinu odvolaných (blacklist) tokenov. Týmto sa zmenší veľkosť uloženého stavu.

Iným, často využívaným, riešením je vydávať tokeny s krátkou platnosť. Platnosť tokenu môže byť uložená v samotnom tokene vo forme časovej pečiatky, času platnosti alebo času expirácie, teda nekladie nároky na stav autorizačnej služby. Pri odhlásení klienta ostatnú jemu vydané tokeny platné len krátku dobu, takže útočník má málo času na získanie a zneužitie tokenov. Pri odhalení útoku opakovaním sa klient, pre ktorého boli tokeny vydané odhlási a teda útok bude určite zastavený po krátkom čase, kedy vyprši platnosť tokenom, ktoré útočník získal.

Nejde teda o dokonalú ochranu pred útokom opakovaním, ale zťaženie jeho vykonania útočníkovi a zníženie jeho dopadov. Túto ochranu podľa špecifikácie podporujú tokeny Fernet a Branca. Formáty oboch musia obsahovať časovú pečiatku vo formáte počet sekúnd od 1.1.1970 v UTC časovej zóne. V prípade Branca tokenu ide o 32 bitové číslo, no vo formáte bez znamienka, čo posúva 2038 problém \cite{epoch_end} na rok 2106. Stále však ide o potenciálny problém za cenu ušetrenia 4B dát v tokene. Všetky ostatné tokeny vedia túto metódu ľahko implemetntovať. Využíva ju aj populárny protokol OAuth 2.0 \cite{oauth2}.

Macaroons a Biscuits poskytujú možnosť pridávať pravidlá tretích strán, takto môžu pridať pravidlo na službu udržujúcu whitelist alebo blacklist tokenov. Týmto odľahčia autorizačnú službu od udržiavania stavu o vydaných tokenoch a zároveň budú poskytovať úplnú ochranu pred útokom opakovaním. Stav však z autorizačnej schémy nezmizol, iba sa presunul do inej služby a nutnosť získať dôkaz o tom, že token nebol odvolaný sa presunul z autorizačnej služby na klienta posielajúceho požiadavku.

